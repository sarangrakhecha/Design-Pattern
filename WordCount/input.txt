Design Patterns Elements of Reusable ObjectOriented Software is a software engineering book describing recurring solutions to common problems in software design The books authors are Erich Gamma Richard Helm Ralph Johnson and John Vlissides with a foreword by Grady Booch The book is divided into two parts with the first two chapters exploring the capabilities and pitfalls of objectoriented programming and the remaining chapters describing  classic software design patterns The book includes examples in C and Smalltalk

It has been highly influential to the field of software engineering and is regarded as an important source for objectoriented design theory and practice More than  copies have been sold in English and in  other languages The authors are often referred to as the Gang of Four GoF

History
The book started at a birds of a feather BoF session at OOPSLA  Towards an Architecture Handbook run by Bruce Anderson where Erich Gamma and Richard Helm met and discovered their common interest They were later joined by Ralph Johnson and John Vlissides The original publication date of the book was October   with a  copyright hence it is often cited with a year despite being published in  The book was first made available to the public at the OOPSLA meeting held in Portland Oregon in October  In  the ACM SIGPLAN awarded that years Programming Languages Achievement Award to the authors in recognition of the impact of their work on programming practice and programming language design As of March  the book was in its th printingIntroduction Chapter 

Chapter  is a discussion of objectoriented design techniques based on the authors experience which they believe would lead to good objectoriented software design including

    Program to an interface not an implementation Gang of Four 
    Composition over inheritance Favor object composition over class inheritance Gang of Four 

The authors claim the following as advantages of interfaces over implementation

    clients remain unaware of the specific types of objects they use as long as the object adheres to the interface
    clients remain unaware of the classes that implement these objects clients only know about the abstract classes defining the interface

Use of an interface also leads to dynamic binding and polymorphism which are central features of objectoriented programming

The authors refer to inheritance as whitebox reuse with whitebox referring to visibility because the internals of parent classes are often visible to subclasses In contrast the authors refer to object composition in which objects with welldefined interfaces are used dynamically at runtime by objects obtaining references to other objects as blackbox reuse because no internal details of composed objects needs to be visible in the code using them

The authors discuss the tension between inheritance and encapsulation at length and state that in their experience designers overuse inheritance Gang of Four  The danger is stated as follows

    Because inheritance exposes a subclass to details of its parents implementation its often said that inheritance breaks encapsulation Gang of Four 

They warn that the implementation of a subclass can become so bound up with the implementation of its parent class that any change in the parents implementation will force the subclass to change Furthermore they claim that a way to avoid this is to inherit only from abstract classes but then they point out that there is minimal code reuse

Using inheritance is recommended mainly when adding to the functionality of existing components reusing most of the old code and adding relatively small amounts of new code

To the authors delegation is an extreme form of object composition that can always be used to replace inheritance Delegation involves two objects a sender passes itself to a delegate to let the delegate refer to the sender Thus the link between two parts of a system are established only at runtime not at compiletime The Callback article has more information about delegation

The authors also discuss socalled parameterized types which are also known as generics Ada Eiffel Java C VBNET and Delphi or templates C These allow any type to be defined without specifying all the other types it uses the unspecified types are supplied as parameters at the point of use

The authors admit that delegation and parameterization are very powerful but add a warning

    Dynamic highly parameterized software is harder to understand and build than more static software Gang of Four 

The authors further distinguish between Aggregation where one object has or is part of another object implying that an aggregate object and its owner have identical lifetimes and acquaintance where one object merely knows of another object Sometimes acquaintance is called association or the using relationship Acquaintance objects may request operations of each other but they arent responsible for each other Acquaintance is a weaker relationship than aggregation and suggests much looser coupling between objects which can often be desirable for maximum maintainability in a design

The authors employ the term toolkit where others might today use class library as in C or Java In their parlance toolkits are the objectoriented equivalent of subroutine libraries whereas a framework is a set of cooperating classes that make up a reusable design for a specific class of software They state that applications are hard to design toolkits are harder and frameworks are the hardest to designCase study Chapter 

Chapter  is a stepbystep case study on the design of a WhatYouSeeIsWhatYouGet or WYSIWYG document editor called Lexi pp

The chapter goes through seven problems that must be addressed in order to properly design Lexi including any constraints that must be followed Each problem is analyzed in depth and solutions are proposed Each solution is explained in full including pseudocode and a slightly modified version of Object Modeling Technique where appropriate

Finally each solution is associated directly with one or more design patterns It is shown how the solution is a direct implementation of that design pattern

The seven problems including their constraints and their solutions including the patterns referenced are as follows
Document Structure

The document is an arrangement of basic graphical elements such as characters lines other shapes etc that capture the total information content of the documentpp The structure of the document contains a collection of these elements and each element can in turn be a substructure of other elements

Problems and Constraints

    Text and graphics should be treated the same way that is graphics arent a derived instance of text nor vice versa
    The implementation should treat complex and simple structures the same way It should not have to know the difference between the two
    Specific derivatives of abstract elements should have specialized analytical elements

Solution and Pattern

A recursive composition is a hierarchical structure of elements that builds increasingly complex elements out of simpler ones pp Each node in the structure knows of its own children and its parent If an operation is to be performed on the whole structure each node calls the operation on its children recursively

This is an implementation of the composite pattern which is a collection of nodes The node is an abstract base class and derivatives can either be leaves singular or collections of other nodes which in turn can contain leaves or collectionnodes When an operation is performed on the parent that operation is recursively passed down the hierarchy
Formatting

Formatting differs from structure Formatting is a method of constructing a particular instance of the documents physical structure This includes breaking text into lines using hyphens adjusting for margin widths etc

Problems and Constraints

    Balance between formatting quality speed and storage space
    Keep formatting independent uncoupled from the document structure

Solution and Pattern

A Compositor class will encapsulate the algorithm used to format a composition Compositor is a subclass of the primitive object of the documents structure A Compositor has an associated instance of a Composition object When a Compositor runs its Compose it iterates through each element of its associated Composition and rearranges the structure by inserting Row and Column objects as needed

The Compositor itself is an abstract class allowing for derivative classes to use different formatting algorithms such as doublespacing wider margins etc

The Strategy Pattern is used to accomplish this goal A Strategy is a method of encapsulating multiple algorithms to be used based on a changing context In this case formatting should be different depending on whether text graphics simple elements etc are being formatted
Embellishing the User Interface

The ability to change the graphical interface that the user uses to interact with the document

Problems and Constraints

    Demarcate a page of text with a border around the editing area
    Scroll bars that let the user view different parts of the page
    User interface objects should not know about the embellishments
    Avoid an explosion of classes that would be caused by subclassing for every possible combination of embellishments and elements p

Solution and Pattern

The use of a transparent enclosure allows elements that augment the behaviour of composition to be added to a composition These elements such as Border and Scroller are special subclasses of the singular element itself This allows the composition to be augmented effectively adding statelike elements Since these augmentations are part of the structure their appropriate Operation will be called when the structures Operation is called This means that the client does not need any special knowledge or interface with the structure in order to use the embellishments

This is a Decorator pattern one that adds responsibilities to an object without modifying the object itself
Supporting Multiple LookAndFeel Standards

Lookandfeel refers to platformspecific UI standards These standards define guidelines for how applications appear and react to the user pp

Problems and Constraints

    The editor must implement standards of multiple platforms so that it is portable
    Easily adapt to new and emergent standards
    Allow for runtime changing of lookandfeel ie No hardcoding
    Have a set of abstract elemental subclasses for each category of elements ScrollBar Buttons etc
    Have a set of concrete subclasses for each abstract subclass that can have a different lookandfeel standard ScrollBar having MotifScrollBar and PresentationScrollBar for Motif and Presentation lookandfeels

Solution and Pattern

Since object creation of different concrete objects cannot be done at runtime the object creation process must be abstracted This is done with an abstract guiFactory which takes on the responsibility of creating UI elements The abstract guiFactory has concrete implementations such as MotifFactory which creates concrete elements of the appropriate type MotifScrollBar In this way the program need only ask for a ScrollBar and at runtime it will be given the correct concrete element

This is an Abstract Factory A regular factory creates concrete objects of one type An abstract factory creates concrete objects of varying types depending on the concrete implementation of the factory itself Its ability to focus on not just concrete objects but entire families of concrete objects distinguishes it from other creational patterns which involve only one kind of product object pp
Supporting Multiple Window Systems

Just as lookandfeel is different across platforms so is the method of handling windows Each platform displays lays out handles input to and output from and layers windows differently

Problems and Constraints

    The document editor must run on many of the important and largely incompatible window systems that exist p 
    An Abstract Factory cannot be used Due to differing standards there will not be a common abstract class for each type of widget
    Do not create a new nonstandard windowing system

Solution and Pattern

It is possible to develop our own abstract and concrete product classes because all window systems do generally the same thing p  Each window system provides operations for drawing primitive shapes iconifyingdeiconifying resizing and refreshing window contents

An abstract base Window class can be derived to the different types of existing windows such as application iconified dialog These classes will contain operations that are associated with windows such as reshaping graphically refreshing etc Each window contains elements whose Draw functions are called upon by the Windows own drawrelated functions

In order to avoid having to create platformspecific Window subclasses for every possible platform an interface will be used The Window class will implement a Window implementation WindowImp abstract class This class will then in turn be derived into multiple platformspecific implementations each with platformspecific operations Hence only one set of Window classes are needed for each type of Window and only one set of WindowImp classes are needed for each platform rather than the Cartesian product of all available types and platforms In addition adding a new window type does not require any modification of platform implementation or vice versa

This is a Bridge pattern Window and WindowImp are different but related Window deals with windowing in the program and WindowImp deals with windowing on a platform One of them can change without ever having to modify the other The Bridge pattern allows these two separate class hierarchies to work together even as they evolve independently p 
User Operations

All actions the user can take with the document ranging from entering text changing formatting quitting saving etc

Problems and Constraints

    Operations must be accessed through different inputs such as a menu option and a keyboard shortcut for the same command
    Each option has an interface which should be modifiable
    Operations are implemented in several different classes
    In order to avoid coupling there must not be a lot of dependencies between implementation and user interface classes
    Undo and redo commands must be supported on most document changing operations with no arbitrary limit on the number of levels of undo
    Functions are not viable since they dont undoredo easily are not easily associated with a state and are hard to extend or reuse
    Menus should be treated like hierarchical composite structures Hence a menu is a menu item that contains menu items which may contain other menu items etc

Solution and Pattern

Each menu item rather than being instantiated with a list of parameters is instead done with a Command object

Command is an abstract object that only has a single abstract Execute method Derivative objects extend the Execute method appropriately ie the PasteCommandExecute would utilize the contents clipboard buffer These objects can be used by widgets or buttons just as easily as they can be used by menu items

To support undo and redo Command is also given Unexecute and Reversible In derivative classes the former contains code that will undo that command and the latter returns a boolean value that defines if the command is undoable Reversible allows some commands to be nonundoable such as a Save command

All executed Commands are kept in a list with a method of keeping a present marker directly after the most recently executed command A request to undo will call the CommandUnexecute directly before present then move present back one command Conversely a Redo request will call CommandExecute after present and move present forward one

This Command approach is an implementation of the Command pattern It encapsulates requests in objects and uses a common interface to access those requests Thus the client can handle different requests and commands can be scattered throughout the application
Spell Check and Hyphenation

This is the document editors ability to textually analyze the contents of a document Although there are many analyses that can be performed spell check and hyphenationformatting are the focus

Problems and Constraints

    Allow for multiple ways to check spelling and identify places for hyphenation
    Allow for expansion for future analysis eg word count grammar check
    Be able to iterate through a texts contents without access to the texts actual structure eg array linked list string
    Allow for any manner of traversal of document beginning to end end to beginning alphabetical order etc

Solution and Pattern

Removing the integerbased index from the basic element allows for a different iteration interface to be implemented This will require extra methods for traversal and object retrieval These methods are put into an abstract Iterator interface Each element then implements a derivation of the Iterator depending on how that element keeps its list ArrayIterator LinkListIterator etc

Functions for traversal and retrieval are put into the abstract Iterator interface Future Iterators can be derived based on the type of list they will be iterating through such as Arrays or Linked Lists Thus no matter what type of indexing method any implementation of the element uses it will have the appropriate Iterator

This is an implementation of the Iterator pattern It allows the client to traverse through any object collection without needing to access the contents of the collection directly or be concerned about the type of list the collections structure uses

Now that traversal has been handled it is possible to analyze the elements of a structure It is not feasible to build each type of analysis into the element structure themselves every element would need to be coded and much of the code would be the same for similar elements

Instead a generic CheckMe method is built into the elements abstract class Each Iterator is given a reference to a specific algorithm such as spell check grammar check etc When that Iterator iterates through its collection it calls each elements CheckMe passing the specified algorithm CheckMe then passes a reference to its element back to said algorithm for analysis

Thus to perform a spell check a fronttoend iterator would be given a reference to a SpellCheck object The iterator would then access each element executing its CheckMe method with the SpellCheck parameter Each CheckMe would then call the SpellCheck passing a reference to the appropriate element

In this manner any algorithm can be used with any traversal method without hardcode coupling one with the other For example Find can be used as find next or find previous depending on if a forward iterator was used or a backwards iterator

In addition the algorithm themselves can be responsible for dealing with different elements For example a SpellCheck algorithm would ignore a Graphic element rather than having to program every Graphicderived element to not send themselves to a SpellCheck
Patterns by Type
Creational
Main article Creational pattern

Creational patterns are ones that create objects for you rather than having you instantiate objects directly This gives your program more flexibility in deciding which objects need to be created for a given case

    Abstract factory pattern groups object factories that have a common theme
    Builder pattern constructs complex objects by separating construction and representation
    Factory method pattern creates objects without specifying the exact class to create
    Prototype pattern creates objects by cloning an existing object
    Singleton pattern restricts object creation for a class to only one instance

Structural

These concern class and object composition They use inheritance to compose interfaces and define ways to compose objects to obtain new functionality

    Adapter allows classes with incompatible interfaces to work together by wrapping its own interface around that of an already existing class
    Bridge decouples an abstraction from its implementation so that the two can vary independently
    Composite composes zeroormore similar objects so that they can be manipulated as one object
    Decorator dynamically addsoverrides behaviour in an existing method of an object
    Facade provides a simplified interface to a large body of code
    Flyweight reduces the cost of creating and manipulating a large number of similar objects
    Proxy provides a placeholder for another object to control access reduce cost and reduce complexity

Behavioral

Most of these design patterns are specifically concerned with communication between objects

    Chain of responsibility delegates commands to a chain of processing objects
    Command creates objects which encapsulate actions and parameters
    Interpreter implements a specialized language
    Iterator accesses the elements of an object sequentially without exposing its underlying representation
    Mediator allows loose coupling between classes by being the only class that has detailed knowledge of their methods
    Memento provides the ability to restore an object to its previous state undo
    Observer is a publishsubscribe pattern which allows a number of observer objects to see an event
    State allows an object to alter its behavior when its internal state changes
    Strategy allows one of a family of algorithms to be selected onthefly at runtime
    Template method defines the skeleton of an algorithm as an abstract class allowing its subclasses to provide concrete behavior
    Visitor separates an algorithm from an object structure by moving the hierarchy of methods into one object

Criticism

Significant criticism has been directed at the concept of software design patterns generally and at Design Patterns specifically

A primary criticism of Design Patterns is that its patterns are simply workarounds for missing features in C replacing elegant abstract features with lengthy concrete patterns essentially becoming a human compiler or generating by hand the expansions of some macro Peter Norvig demonstrates that  out of the  patterns in Design Patterns are simplified or eliminated via direct language support in Lisp or Dylan Related observations were made by Hannemann and Kiczales who implemented several of the  design patterns using an aspectoriented programming language AspectJ and showed that codelevel dependencies were removed from the implementations of  of the  design patterns and that aspectoriented programming could simplify the implementations of design patterns

There has also been humorous criticism such as a show trial at OOPSLA  on  November a and a parody of the format by Jim Coplien entitled Kansas City Air Conditioner

Design patterns represent the best practices used by experienced objectoriented software developers Design patterns are solutions to general problems that software developers faced during software development These solutions were obtained by trial and error by numerous software developers over quite a substantial period of time

This tutorial will take you through step by step approach and examples using Java while learning Design Pattern concepts
Audience

This reference has been prepared for the experienced developers to provide best solutions to certain problems faced during software development and for unexperienced developers to learn software design in an easy and faster way
Prerequisites

Before you start proceeding with this tutorial Im making an assumption that you are already aware about basic java programming concepts If you are not well aware of these concepts then I will suggest to go through our short tutorial on Java ProgrammingDesign patterns represent the best practices used by experienced objectoriented software developers Design patterns are solutions to general problems that software developers faced during software development These solutions were obtained by trial and error by numerous software developers over quite a substantial period of time
What is Gang of Four GOF

In  four authors Erich Gamma Richard Helm Ralph Johnson and John Vlissides published a book titled Design Patterns  Elements of Reusable ObjectOriented Software which initiated the concept of Design Pattern in Software development

These authors are collectively known as Gang of Four GOF According to these authors design patterns are primarily based on the following principles of object orientated design

    Program to an interface not an implementation

    Favor object composition over inheritance

Usage of Design Pattern

Design Patterns have two main usages in software development
Common platform for developers

Design patterns provide a standard terminology and are specific to particular scenario For example a singleton design pattern signifies use of single object so all developers familiar with single design pattern will make use of single object and they can tell each other that program is following a singleton pattern
Best Practices

Design patterns have been evolved over a long period of time and they provide best solutions to certain problems faced during software development Learning these patterns helps unexperienced developers to learn software design in an easy and faster way
Types of Design Patterns

As per the design pattern reference book Design Patterns  Elements of Reusable ObjectOriented Software  there are  design patterns which can be classified in three categories Creational Structural and Behavioral patterns Well also discuss another category of design pattern JEE design patterns
SN	Pattern  Description
	Creational Patterns
These design patterns provide a way to create objects while hiding the creation logic rather than instantiating objects directly using new opreator This gives program more flexibility in deciding which objects need to be created for a given use case
	Structural Patterns
These design patterns concern class and object composition Concept of inheritance is used to compose interfaces and define ways to compose objects to obtain new functionalities
	Behavioral Patterns
These design patterns are specifically concerned with communication between objects
	JEE Patterns
These design patterns are specifically concerned with the presentation tier These patterns are identified by Sun Java CenterFactory pattern is one of most used design pattern in Java This type of design pattern comes under creational pattern as this pattern provides one of the best ways to create an object

In Factory pattern we create object without exposing the creation logic to the client and refer to newly created object using a common interface
Implementation

Were going to create a Shape interface and concrete classes implementing the Shape interface A factory class ShapeFactory is defined as a next step

FactoryPatternDemo our demo class will use ShapeFactory to get a Shape object It will pass information CIRCLE  RECTANGLE  SQUARE to ShapeFactory to get the type of object it needsAbstract Factory patterns work around a superfactory which creates other factories This factory is also called as factory of factories This type of design pattern comes under creational pattern as this pattern provides one of the best ways to create an object

In Abstract Factory pattern an interface is responsible for creating a factory of related objects without explicitly specifying their classes Each generated factory can give the objects as per the Factory pattern
Implementation

We are going to create a Shape and Color interfaces and concrete classes implementing these interfaces We create an abstract factory class AbstractFactory as next step Factory classes ShapeFactory and ColorFactory are defined where each factory extends AbstractFactory A factory creatorgenerator class FactoryProducer is created

AbstractFactoryPatternDemo our demo class uses FactoryProducer to get a AbstractFactory object It will pass information CIRCLE  RECTANGLE  SQUARE for Shape to AbstractFactory to get the type of object it needs It also passes information RED  GREEN  BLUE for Color to AbstractFactory to get the type of object it needsSingleton pattern is one of the simplest design patterns in Java This type of design pattern comes under creational pattern as this pattern provides one of the best ways to create an object

This pattern involves a single class which is responsible to create an object while making sure that only single object gets created This class provides a way to access its only object which can be accessed directly without need to instantiate the object of the class
Implementation

Were going to create a SingleObject class SingleObject class have its constructor as private and have a static instance of itself

SingleObject class provides a static method to get its static instance to outside world SingletonPatternDemo our demo class will use SingleObject class to get a SingleObject objectBuilder pattern builds a complex object using simple objects and using a step by step approach This type of design pattern comes under creational pattern as this pattern provides one of the best ways to create an object

A Builder class builds the final object step by step This builder is independent of other objects
Implementation

We have considered a business case of fastfood restaurant where a typical meal could be a burger and a cold drink Burger could be either a Veg Burger or Chicken Burger and will be packed by a wrapper Cold drink could be either a coke or pepsi and will be packed in a bottle

We are going to create an Item interface representing food items such as burgers and cold drinks and concrete classes implementing the Item interface and a Packing interface representing packaging of food items and concrete classes implementing the Packing interface as burger would be packed in wrapper and cold drink would be packed as bottle

We then create a Meal class having ArrayList of Item and a MealBuilder to build different types of Meal objects by combining Item BuilderPatternDemo our demo class will use MealBuilder to build a MealPrototype pattern refers to creating duplicate object while keeping performance in mind This type of design pattern comes under creational pattern as this pattern provides one of the best ways to create an object

This pattern involves implementing a prototype interface which tells to create a clone of the current object This pattern is used when creation of object directly is costly For example an object is to be created after a costly database operation We can cache the object returns its clone on next request and update the database as and when needed thus reducing database calls
Implementation

Were going to create an abstract class Shape and concrete classes extending the Shape class A class ShapeCache is defined as a next step which stores shape objects in a Hashtable and returns their clone when requested

PrototypPatternDemo our demo class will use ShapeCache class to get a Shape objectAdapter pattern works as a bridge between two incompatible interfaces This type of design pattern comes under structural pattern as this pattern combines the capability of two independent interfaces

This pattern involves a single class which is responsible to join functionalities of independent or incompatible interfaces A real life example could be a case of card reader which acts as an adapter between memory card and a laptop You plugin the memory card into card reader and card reader into the laptop so that memory card can be read via laptop

We are demonstrating use of Adapter pattern via following example in which an audio player device can play mp files only and wants to use an advanced audio player capable of playing vlc and mp files
Implementation

We have a MediaPlayer interface and a concrete class AudioPlayer implementing the MediaPlayer interface AudioPlayer can play mp format audio files by default

We are having another interface AdvancedMediaPlayer and concrete classes implementing the AdvancedMediaPlayer interface These classes can play vlc and mp format files

We want to make AudioPlayer to play other formats as well To attain this we have created an adapter class MediaAdapter which implements the MediaPlayer interface and uses AdvancedMediaPlayer objects to play the required format

AudioPlayer uses the adapter class MediaAdapter passing it the desired audio type without knowing the actual class which can play the desired format AdapterPatternDemo our demo class will use AudioPlayer class to play various formatsBridge is used when we need to decouple an abstraction from its implementation so that the two can vary independently This type of design pattern comes under structural pattern as this pattern decouples implementation class and abstract class by providing a bridge structure between them

This pattern involves an interface which acts as a bridge which makes the functionality of concrete classes independent from interface implementer classes Both types of classes can be altered structurally without affecting each other

We are demonstrating use of Bridge pattern via following example in which a circle can be drawn in different colors using same abstract class method but different bridge implementer classes
Implementation

We have a DrawAPI interface which is acting as a bridge implementer and concrete classes RedCircle GreenCircle implementing the DrawAPI interface Shape is an abstract class and will use object of DrawAPI BridgePatternDemo our demo class will use Shape class to draw different colored circleFilter pattern or Criteria pattern is a design pattern that enables developers to filter a set of objects using different criteria and chaining them in a decoupled way through logical operations This type of design pattern comes under structural pattern as this pattern combines multiple criteria to obtain single criteria

Implementation

Were going to create a Person object Criteria interface and concrete classes implementing this interface to filter list of Person objects CriteriaPatternDemo our demo class uses Criteria objects to filter List of Person objects based on various criteria and their combinationsComposite pattern is used where we need to treat a group of objects in similar way as a single object Composite pattern composes objects in term of a tree structure to represent part as well as whole hierarchy This type of design pattern comes under structural pattern as this pattern creates a tree structure of group of objects

This pattern creates a class that contains group of its own objects This class provides ways to modify its group of same objects

We are demonstrating use of composite pattern via following example in which we will show employees hierarchy of an organizationImplementation

We have a class Employee which acts as composite pattern actor class CompositePatternDemo our demo class will use Employee class to add department level hierarchy and print all employeesFilter pattern or Criteria pattern is a design pattern that enables developers to filter a set of objects using different criteria and chaining them in a decoupled way through logical operations This type of design pattern comes under structural pattern as this pattern combines multiple criteria to obtain single criteria

Implementation

Were going to create a Person object Criteria interface and concrete classes implementing this interface to filter list of Person objects CriteriaPatternDemo our demo class uses Criteria objects to filter List of Person objects based on various criteria and their combinationsComposite pattern is used where we need to treat a group of objects in similar way as a single object Composite pattern composes objects in term of a tree structure to represent part as well as whole hierarchy This type of design pattern comes under structural pattern as this pattern creates a tree structure of group of objects

This pattern creates a class that contains group of its own objects This class provides ways to modify its group of same objects

We are demonstrating use of composite pattern via following example in which we will show employees hierarchy of an organization
Implementation

We have a class Employee which acts as composite pattern actor class CompositePatternDemo our demo class will use Employee class to add department level hierarchy and print all employeesDecorator pattern allows a user to add new functionality to an existing object without altering its structure This type of design pattern comes under structural pattern as this pattern acts as a wrapper to existing class

This pattern creates a decorator class which wraps the original class and provides additional functionality keeping class methods signature intact

We are demonstrating the use of decorator pattern via following example in which we will decorate a shape with some color without alter shape class
Implementation

Were going to create a Shape interface and concrete classes implementing the Shape interface We will then create an abstract decorator class ShapeDecorator implementing the Shape interface and having Shape object as its instance variable

RedShapeDecorator is concrete class implementing ShapeDecorator

DecoratorPatternDemo our demo class will use RedShapeDecorator to decorate Shape objectsFacade pattern hides the complexities of the system and provides an interface to the client using which the client can access the system This type of design pattern comes under structural pattern as this pattern adds an interface to existing system to hide its complexities

This pattern involves a single class which provides simplified methods required by client and delegates calls to methods of existing system classes
Implementation

We are going to create a Shape interface and concrete classes implementing the Shape interface A facade class ShapeMaker is defined as a next step

ShapeMaker class uses the concrete classes to delegate user calls to these classes FacadePatternDemo our demo class will use ShapeMaker class to show the resultsFlyweight pattern is primarily used to reduce the number of objects created and to decrease memory footprint and increase performance This type of design pattern comes under structural pattern as this pattern provides ways to decrease object count thus improving the object structure of application

Flyweight pattern tries to reuse already existing similar kind objects by storing them and creates new object when no matching object is found We will demonstrate this pattern by drawing  circles of different locations but we will create only  objects Only  colors are available so color property is used to check already existing Circle objects
Implementation

We are going to create a Shape interface and concrete class Circle implementing the Shape interface A factory class ShapeFactory is defined as a next step

ShapeFactory has a HashMap of Circle having key as color of the Circle object Whenever a request comes to create a circle of particular color to ShapeFactory it checks the circle object in its HashMap if object of Circle found that object is returned otherwise a new object is created stored in hashmap for future use and returned to client

FlyWeightPatternDemo our demo class will use ShapeFactory to get a Shape object It will pass information red  green  blue black  white to ShapeFactory to get the circle of desired color it needsIn proxy pattern a class represents functionality of another class This type of design pattern comes under structural pattern

In proxy pattern we create object having original object to interface its functionality to outer world
Implementation

We are going to create an Image interface and concrete classes implementing the Image interface ProxyImage is a a proxy class to reduce memory footprint of RealImage object loading

ProxyPatternDemo our demo class will use ProxyImage to get an Image object to load and display as it needsFacade pattern hides the complexities of the system and provides an interface to the client using which the client can access the system This type of design pattern comes under structural pattern as this pattern adds an interface to existing system to hide its complexities

This pattern involves a single class which provides simplified methods required by client and delegates calls to methods of existing system classes
Implementation

We are going to create a Shape interface and concrete classes implementing the Shape interface A facade class ShapeMaker is defined as a next step

ShapeMaker class uses the concrete classes to delegate user calls to these classes FacadePatternDemo our demo class will use ShapeMaker class to show the resultsIn proxy pattern a class represents functionality of another class This type of design pattern comes under structural pattern

In proxy pattern we create object having original object to interface its functionality to outer world
Implementation

We are going to create an Image interface and concrete classes implementing the Image interface ProxyImage is a a proxy class to reduce memory footprint of RealImage object loading

ProxyPatternDemo our demo class will use ProxyImage to get an Image object to load and display as it needsAs the name suggests the chain of responsibility pattern creates a chain of receiver objects for a request This pattern decouples sender and receiver of a request based on type of request This pattern comes under behavioral patterns

In this pattern normally each receiver contains reference to another receiver If one object cannot handle the request then it passes the same to the next receiver and so on
Implementation

We have created an abstract class AbstractLogger with a level of logging Then we have created three types of loggers extending the AbstractLogger Each logger checks the level of message to its level and print accordingly otherwise does not print and pass the message to its next loggerCommand pattern is a data driven design pattern and falls under behavioral pattern category A request is wrapped under an object as command and passed to invoker object Invoker object looks for the appropriate object which can handle this command and passes the command to the corresponding object which executes the command

Implementation

We have created an interface Order which is acting as a command We have created a Stock class which acts as a request We have concrete command classes BuyStock and SellStock implementing Order interface which will do actual command processing A class Broker is created which acts as an invoker object It can take and place orders

Broker object uses command pattern to identify which object will execute which command based on the type of command CommandPatternDemo our demo class will use Broker class to demonstrate command patternInterpreter pattern provides a way to evaluate language grammar or expression This type of pattern comes under behavioral pattern This pattern involves implementing an expression interface which tells to interpret a particular context This pattern is used in SQL parsing symbol processing engine etc
Implementation

We are going to create an interface Expression and concrete classes implementing the Expression interface A class TerminalExpression is defined which acts as a main interpreter of context in question Other classes OrExpression AndExpression are used to create combinational expressions

InterpreterPatternDemo our demo class will use Expression class to create rules and demonstrate parsing of expressions
